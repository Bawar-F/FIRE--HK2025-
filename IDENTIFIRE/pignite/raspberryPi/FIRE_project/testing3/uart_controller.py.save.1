import serial
import time
from enum import Enum
import config


class SystemState(Enum):
    IDLE = "idle"
    BUSY = "busy"
    ERROR = "error"


class UARTController:
    """UART communication with Arduino. Commands: START/STOP/STATUS/RESULTS/RESET/FIRESTATUS."""

    def __init__(self, port=None, baudrate=None, timeout=None):
        self.port = port or config.UART_PORT
        self.baudrate = baudrate or config.UART_BAUDRATE
        self.timeout = timeout or config.UART_TIMEOUT
        self.serial = None
        self.is_connected = False
        self.state = SystemState.IDLE
        self.last_results = None
        self.last_live_update = None

    def connect(self):
        try:
            self.serial = serial.Serial(self.port, self.baudrate, timeout=self.timeout)
            time.sleep(2)
            self.is_connected = True
            print(f"[UART] Connected to {self.port} at {self.baudrate} baud")
            return True
        except Exception as e:
            print(f"[UART] Failed to connect: {e}")
            self.is_connected = False
            return False

    def disconnect(self):
        if self.serial and self.serial.is_open:
            self.serial.close()
            self.is_connected = False
            print("[UART] Disconnected")

    def read_command(self):
        if not self.is_connected or not self.serial:
            return None
        try:
            if self.serial.in_waiting:
                line = self.serial.readline().decode("utf-8", errors="replace").strip()
                if line:
                    print(f"[UART] Received: {line}")
                    return line
        except Exception as e:
            print(f"[UART] Read error: {e}")
        return None

    def send_response(self, data):
        """Send a plain string over UART."""
        if not self.is_connected or not self.serial:
            print("[UART] Not connected, cannot send")
            return False
        try:
            if isinstance(data, dict):
                data_str = ','.join(f"{k}:{v}" for k, v in data.items())
            else:
                data_str = str(data)

            self.serial.write((data_str + "\n").encode("utf-8"))
            self.serial.flush()

            if config.DEBUG_MODE:
                print(f"[UART] Sent: {data_str}")

            return True
        except Exception as e:
            print(f"[UART] Send error: {e}")
            return False

    def parse_command(self, cmd_str):
        """Parse command string into (command, args_dict)."""
        if not cmd_str:
            return None, None

        parts = cmd_str.split(":")
        command = parts[0].upper()

        if command == "START":
            try:
                duration = int(parts[1]) if len(parts) > 1 else config.DEFAULT_CAPTURE_DURATION
                threshold = int(parts[2]) if len(parts) > 2 else config.BURN_TEMP_DELTA
                return "START", {"duration_sec": duration, "temp_threshold": threshold}
            except:
                return "START", {"duration_sec": config.DEFAULT_CAPTURE_DURATION, "temp_threshold": config.BURN_TEMP_DELTA}

        elif command in ["STOP", "STATUS", "RESULTS", "RESET", "FIRESTATUS", "PING", "]:
            return command, {}

        else:
            return "UNKNOWN", {"original": cmd_str}

    def handle_command(self, command, args, callbacks):
        """Execute command via callbacks and return a plain string."""
        if command == "START":
            if self.state != SystemState.IDLE:
                return f"error: Cannot start, system in {self.state.value} state"
            if 'start' in callbacks:
                success = callbacks['start'](args['duration_sec'], args['temp_threshold'])
                if success:
                    self.state = SystemState.BUSY
                    return "1"
                else:
                    self.state = SystemState.ERROR
                    return "0"

        elif command == "STOP":
            if 'stop' in callbacks:
                callbacks['stop']()
            self.state = SystemState.IDLE
            return "1"

        elif command == "STATUS":
            status_str = self.state.value
            if 'status' in callbacks:
                status_data = callbacks['status']()
                status_str += f", {','.join(f'{k}:{v}' for k,v in status_data.items())}"
            return status_str

        elif command == "RESULTS":
            if self.last_results:
                return ','.join(f"{k}:{v}" for k,v in self.last_results.items())
            else:
                return "No results available"

        elif command == "RESET":
            if 'reset' in callbacks:
                callbacks['reset']()
            self.state = SystemState.IDLE
            self.last_results = None
            return "1"

        elif command == "FIRESTATUS":
            fire_lit = False
            if 'status' in callbacks:
                status_data = callbacks['status']()
                fire_lit = status_data.get('avg_ros_cm2_per_sec', 0) > 0
            return "1" if fire_lit else "0"
        elif command == "PING":
            return "1"

        elif command == "FORCE":
            import importlib
            main = importlib.import_module('main')
            if hasattr(main, "system"):
                system.analyzer.ignition_frame = 1
                system.analyzer.ignition_time = 0.0
            return "1"

        else:
            return f"error: Unknown command {command}"


    def update_state(self, new_state):
        if isinstance(new_state, str):
            new_state = SystemState(new_state)
        self.state = new_state
        print(f"[UART] State: {self.state.value}")

    def store_results(self, results):
        """Store results for RESULTS command."""
        self.last_results = results
        self.state = SystemState.IDLE

